<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Jack The Butler - WebChat Test</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f5f5f5; height: 100vh; display: flex; flex-direction: column; }
    header { background: #1a1a2e; color: #fff; padding: 12px 16px; display: flex; align-items: center; gap: 12px; }
    header h1 { font-size: 16px; font-weight: 600; }
    #status { font-size: 12px; padding: 2px 8px; border-radius: 10px; background: #e74c3c; color: #fff; }
    #status.connected { background: #27ae60; }
    #status.verified { background: #2980b9; }
    #messages { flex: 1; overflow-y: auto; padding: 16px; display: flex; flex-direction: column; gap: 8px; }
    .msg { max-width: 75%; padding: 10px 14px; border-radius: 12px; font-size: 14px; line-height: 1.4; word-wrap: break-word; }
    .msg .label { font-size: 10px; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px; opacity: 0.7; }
    .msg.guest { align-self: flex-end; background: #0084ff; color: #fff; border-bottom-right-radius: 4px; }
    .msg.ai { align-self: flex-start; background: #fff; color: #333; border: 1px solid #e0e0e0; border-bottom-left-radius: 4px; }
    .msg.staff { align-self: flex-start; background: #fff3cd; color: #333; border: 1px solid #ffc107; border-bottom-left-radius: 4px; }
    .msg.system { align-self: center; background: transparent; color: #999; font-size: 12px; font-style: italic; }
    #input-bar { display: flex; gap: 8px; padding: 12px 16px; background: #fff; border-top: 1px solid #e0e0e0; }
    #input-bar input { flex: 1; padding: 10px 14px; border: 1px solid #ddd; border-radius: 20px; font-size: 14px; outline: none; }
    #input-bar input:focus { border-color: #0084ff; }
    #input-bar button { padding: 10px 20px; background: #0084ff; color: #fff; border: none; border-radius: 20px; font-size: 14px; cursor: pointer; }
    #input-bar button:hover { background: #0073e6; }
    #input-bar button:disabled { background: #ccc; cursor: not-allowed; }

    /* Action form styles */
    .action-form { align-self: stretch; background: #f0f4ff; border: 1px solid #c4d4ff; border-radius: 12px; padding: 16px; margin: 4px 0; }
    .action-form h3 { font-size: 14px; font-weight: 600; margin-bottom: 12px; color: #1a1a2e; }
    .action-form .form-field { margin-bottom: 10px; }
    .action-form label { display: block; font-size: 12px; font-weight: 500; margin-bottom: 4px; color: #555; }
    .action-form input, .action-form select { width: 100%; padding: 8px 12px; border: 1px solid #ccc; border-radius: 8px; font-size: 14px; }
    .action-form input:focus, .action-form select:focus { border-color: #0084ff; outline: none; }
    .action-form .form-actions { display: flex; gap: 8px; margin-top: 12px; }
    .action-form button { padding: 8px 16px; border: none; border-radius: 8px; font-size: 13px; cursor: pointer; }
    .action-form button.submit { background: #0084ff; color: #fff; }
    .action-form button.submit:hover { background: #0073e6; }
    .action-form button.cancel { background: #e0e0e0; color: #333; }
    .action-form button.cancel:hover { background: #d0d0d0; }
    .action-form .form-error { color: #e74c3c; font-size: 12px; margin-top: 4px; }
    .action-form .form-field.hidden { display: none; }
  </style>
</head>
<body>
  <header>
    <span>ðŸŽ©</span>
    <h1>Jack The Butler â€” WebChat Test</h1>
    <span id="status">disconnected</span>
  </header>
  <div id="messages"></div>
  <div id="input-bar">
    <input id="input" type="text" placeholder="Type a message..." autocomplete="off" disabled />
    <button id="send" disabled>Send</button>
  </div>

  <script>
    const STORAGE_KEY = 'butlerSessionToken';
    const BUTLER_HOST = location.host || 'localhost:3000';
    const API_BASE = `${location.protocol === 'file:' ? 'http:' : location.protocol}//${BUTLER_HOST}`;
    const messagesEl = document.getElementById('messages');
    const inputEl = document.getElementById('input');
    const sendBtn = document.getElementById('send');
    const statusEl = document.getElementById('status');

    let ws = null;
    let sessionId = null;
    let sessionToken = null;
    let verificationStatus = 'anonymous';
    let reconnectDelay = 1000;
    const MAX_RECONNECT_DELAY = 15000;

    // Action registry (fetched from server)
    let actionDefinitions = [];
    // Pending action to show after verification completes
    let pendingActionId = null;
    // Context carried from a multi-step action (e.g., email for code verification)
    let nextStepContext = null;

    // ============================================
    // Fetch action definitions on load
    // ============================================

    async function fetchActions() {
      try {
        const res = await fetch(`${API_BASE}/api/v1/webchat/actions`);
        if (res.ok) {
          const json = await res.json();
          actionDefinitions = json.actions || [];
          console.log('Loaded action definitions:', actionDefinitions.length);
        }
      } catch (e) {
        console.warn('Failed to fetch actions:', e);
      }
    }

    // ============================================
    // Message rendering
    // ============================================

    function addMessage(content, type, label) {
      const div = document.createElement('div');
      div.className = `msg ${type}`;
      if (label && type !== 'system') {
        const labelEl = document.createElement('div');
        labelEl.className = 'label';
        labelEl.textContent = label;
        div.appendChild(labelEl);
      }
      const text = document.createElement('div');
      text.textContent = content;
      div.appendChild(text);
      messagesEl.appendChild(div);
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    // ============================================
    // Action form rendering
    // ============================================

    function getActionDef(actionId) {
      return actionDefinitions.find(a => a.id === actionId);
    }

    function showActionForm(actionId, overrideFields, context) {
      const action = getActionDef(actionId);
      if (!action && !overrideFields) {
        console.warn('Unknown action:', actionId);
        return;
      }

      const fields = overrideFields || action.fields;
      const formName = action ? action.name : 'Verification Code';

      // Remove any existing action form
      const existing = messagesEl.querySelector('.action-form');
      if (existing) existing.remove();

      const form = document.createElement('div');
      form.className = 'action-form';
      form.innerHTML = `<h3>${formName}</h3>`;

      // Render fields
      for (const field of fields) {
        const fieldDiv = document.createElement('div');
        fieldDiv.className = 'form-field';
        fieldDiv.dataset.key = field.key;

        // Handle showWhen conditional visibility
        if (field.showWhen) {
          fieldDiv.classList.add('hidden');
          fieldDiv.dataset.showWhenField = field.showWhen.field;
          fieldDiv.dataset.showWhenValues = JSON.stringify(field.showWhen.values);
        }

        const label = document.createElement('label');
        label.textContent = field.label + (field.required ? ' *' : '');
        fieldDiv.appendChild(label);

        let input;
        if (field.type === 'select' && field.options) {
          input = document.createElement('select');
          input.name = field.key;
          const emptyOpt = document.createElement('option');
          emptyOpt.value = '';
          emptyOpt.textContent = `Select ${field.label}...`;
          input.appendChild(emptyOpt);
          for (const opt of field.options) {
            const option = document.createElement('option');
            option.value = opt;
            option.textContent = opt.replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
            input.appendChild(option);
          }
          // Add change listener for conditional fields
          input.addEventListener('change', () => updateConditionalFields(form));
        } else {
          input = document.createElement('input');
          input.type = field.type === 'email' ? 'email' : field.type === 'tel' ? 'tel' : field.type === 'date' ? 'date' : 'text';
          input.name = field.key;
          if (field.placeholder) input.placeholder = field.placeholder;
        }

        // Pre-fill from context (e.g., email from step 1)
        if (context && context[field.key]) {
          input.value = context[field.key];
          input.readOnly = true;
          input.style.background = '#f0f0f0';
        }

        fieldDiv.appendChild(input);
        form.appendChild(fieldDiv);
      }

      // Action buttons
      const actionsDiv = document.createElement('div');
      actionsDiv.className = 'form-actions';

      const submitBtn = document.createElement('button');
      submitBtn.className = 'submit';
      submitBtn.textContent = 'Submit';
      submitBtn.addEventListener('click', () => handleFormSubmit(form, actionId, context));

      const cancelBtn = document.createElement('button');
      cancelBtn.className = 'cancel';
      cancelBtn.textContent = 'Cancel';
      cancelBtn.addEventListener('click', () => {
        form.remove();
        pendingActionId = null;
        nextStepContext = null;
      });

      actionsDiv.appendChild(submitBtn);
      actionsDiv.appendChild(cancelBtn);
      form.appendChild(actionsDiv);

      messagesEl.appendChild(form);
      messagesEl.scrollTop = messagesEl.scrollHeight;

      // Trigger initial conditional field visibility
      updateConditionalFields(form);
    }

    function updateConditionalFields(form) {
      const fields = form.querySelectorAll('.form-field[data-show-when-field]');
      for (const field of fields) {
        const depField = field.dataset.showWhenField;
        const allowedValues = JSON.parse(field.dataset.showWhenValues);
        const depInput = form.querySelector(`[name="${depField}"]`);
        if (depInput && allowedValues.includes(depInput.value)) {
          field.classList.remove('hidden');
        } else {
          field.classList.add('hidden');
        }
      }
    }

    async function handleFormSubmit(form, actionId, context) {
      // Collect field values
      const inputs = form.querySelectorAll('input, select');
      const data = {};

      // Merge context first (carried from previous step)
      if (context) {
        Object.assign(data, context);
      }

      for (const input of inputs) {
        if (input.name && !input.closest('.hidden')) {
          data[input.name] = input.value;
        }
      }

      // Validate required fields
      const action = getActionDef(actionId);
      const fields = action ? action.fields : [];
      for (const field of fields) {
        if (field.required && field.showWhen) {
          const depInput = form.querySelector(`[name="${field.showWhen.field}"]`);
          if (!depInput || !field.showWhen.values.includes(depInput.value)) continue;
        }
        if (field.required && !data[field.key]) {
          addMessage(`Please fill in: ${field.label}`, 'system');
          return;
        }
      }

      // Show submitting state
      const submitBtn = form.querySelector('.submit');
      submitBtn.disabled = true;
      submitBtn.textContent = 'Submitting...';

      try {
        const res = await fetch(`${API_BASE}/api/v1/webchat/actions/${actionId}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${sessionToken}`,
          },
          body: JSON.stringify(data),
        });

        const result = await res.json();

        // Remove the form
        form.remove();

        if (result.success) {
          // If there's a next step (multi-step action), show the next form
          if (result.nextStep) {
            addMessage(result.message, 'system');
            nextStepContext = result.nextStep.context || {};
            showActionForm(actionId, result.nextStep.fields, nextStepContext);
            return;
          }

          // Success â€” the server persists and broadcasts the result as a system message
          // so we don't need to add it manually (it arrives via WS).
          // But if there's a pending action from verification chaining, show it now.
          if (actionId === 'verify-reservation' && pendingActionId) {
            const pending = pendingActionId;
            pendingActionId = null;
            // Small delay so the verification success message appears first
            setTimeout(() => showActionForm(pending), 300);
          }
        } else {
          addMessage(result.message || 'Action failed.', 'system');

          // For verification errors, keep the form visible for retry
          if (result.error !== 'attempts_exceeded' && result.error !== 'invalid_session') {
            showActionForm(actionId, null, context);
          }
        }
      } catch (e) {
        form.remove();
        addMessage('Failed to submit form. Please try again.', 'system');
        console.error('Action submit error:', e);
      }

      nextStepContext = null;
    }

    // ============================================
    // Verification chaining
    // ============================================

    function handleActionTrigger(actionId) {
      const action = getActionDef(actionId);
      if (!action) {
        console.warn('Unknown action triggered:', actionId);
        return;
      }

      if (action.requiresVerification && verificationStatus !== 'verified') {
        // Chain: show verification first, then the requested action
        pendingActionId = actionId;
        addMessage('Please verify your booking first.', 'system');
        showActionForm('verify-reservation');
      } else {
        showActionForm(actionId);
      }
    }

    // ============================================
    // Connection
    // ============================================

    function setConnected(connected) {
      const label = connected
        ? (verificationStatus === 'verified' ? 'verified' : 'connected')
        : 'disconnected';
      statusEl.textContent = label;
      statusEl.className = connected
        ? (verificationStatus === 'verified' ? 'connected verified' : 'connected')
        : '';
      inputEl.disabled = !connected;
      sendBtn.disabled = !connected;
      if (connected) inputEl.focus();
    }

    function connect() {
      const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
      const host = location.host || 'localhost:3000';
      let url = `${protocol}//${host}/ws/chat`;

      // Append session token if we have one
      const token = localStorage.getItem(STORAGE_KEY);
      if (token) {
        url += `?token=${encodeURIComponent(token)}`;
      }

      addMessage('Connecting...', 'system');
      ws = new WebSocket(url);

      ws.onopen = () => {
        reconnectDelay = 1000;
      };

      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);

          switch (data.type) {
            case 'session':
              // Store token for future reconnects
              sessionToken = data.token;
              localStorage.setItem(STORAGE_KEY, data.token);
              sessionId = data.sessionId;
              verificationStatus = data.verificationStatus || 'anonymous';
              setConnected(true);

              if (data.restored) {
                addMessage('Session restored â€” loading previous messages...', 'system');
              } else if (data.previousExpired) {
                addMessage('Previous session expired. Starting fresh.', 'system');
              } else {
                addMessage('Connected â€” new session', 'system');
              }
              break;

            case 'session_update':
              // Verification status changed (broadcast from another tab or action result)
              if (data.verificationStatus) {
                verificationStatus = data.verificationStatus;
                setConnected(true);

                // If we had a pending action and just got verified, show it
                if (verificationStatus === 'verified' && pendingActionId) {
                  const pending = pendingActionId;
                  pendingActionId = null;
                  setTimeout(() => showActionForm(pending), 300);
                }
              }
              break;

            case 'history':
              // Render conversation history
              if (data.messages && data.messages.length > 0) {
                for (const msg of data.messages) {
                  if (msg.direction === 'inbound') {
                    addMessage(msg.content, 'guest', 'You');
                  } else if (msg.senderType === 'staff') {
                    addMessage(msg.content, 'staff', 'Staff');
                  } else if (msg.senderType === 'system') {
                    addMessage(msg.content, 'system');
                  } else {
                    addMessage(msg.content, 'ai', 'AI');
                  }
                }
                addMessage(`${data.messages.length} previous messages loaded`, 'system');
              }
              break;

            case 'message':
              if (data.senderType === 'system') {
                addMessage(data.content, 'system');
              } else if (data.senderType === 'ai') {
                addMessage(data.content, 'ai', 'AI');
                // Check if the AI triggered an action
                if (data.action && data.action.id) {
                  handleActionTrigger(data.action.id);
                }
              } else if (data.senderType === 'staff') {
                addMessage(data.content, 'staff', 'Staff');
              } else if (data.direction === 'inbound') {
                addMessage(data.content, 'guest', 'You (other tab)');
              }
              break;

            case 'error':
              addMessage(`Error: ${data.message}`, 'system');
              break;

            case 'pong':
              break;

            default:
              console.log('Unknown message:', data);
          }
        } catch (e) {
          console.error('Failed to parse message:', e);
        }
      };

      ws.onclose = () => {
        setConnected(false);
        addMessage('Disconnected. Reconnecting...', 'system');
        setTimeout(() => {
          reconnectDelay = Math.min(reconnectDelay * 1.5, MAX_RECONNECT_DELAY);
          connect();
        }, reconnectDelay);
      };

      ws.onerror = (err) => {
        console.error('WebSocket error:', err);
      };
    }

    function sendMessage() {
      const content = inputEl.value.trim();
      if (!content || !ws || ws.readyState !== WebSocket.OPEN) return;

      ws.send(JSON.stringify({ type: 'message', content }));
      addMessage(content, 'guest', 'You');
      inputEl.value = '';
      inputEl.focus();
    }

    sendBtn.addEventListener('click', sendMessage);
    inputEl.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') sendMessage();
    });

    // Fetch actions first, then connect
    fetchActions().then(() => connect());
  </script>
</body>
</html>
